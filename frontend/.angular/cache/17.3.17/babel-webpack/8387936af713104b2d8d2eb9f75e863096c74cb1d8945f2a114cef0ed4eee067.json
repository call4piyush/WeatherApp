{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { Subject, BehaviorSubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nlet AppComponent = class AppComponent {\n  constructor(weatherService, cityService) {\n    this.weatherService = weatherService;\n    this.cityService = cityService;\n    this.title = 'weather-app-frontend';\n    this.searchCity = '';\n    this.currentCity = '';\n    this.forecasts = [];\n    this.lastSearchResponse = null;\n    // City autocomplete properties\n    this.searchInput$ = new Subject();\n    this.citySuggestions = [];\n    this.showSuggestions = false;\n    this.selectedCityIndex = -1;\n    // Loading and error states\n    this.loading$ = new BehaviorSubject(false);\n    this.cityLoading$ = new BehaviorSubject(false);\n    this.error = null;\n    this.cityError = null;\n    this.offlineMode$ = new BehaviorSubject(false);\n    // Cached cities for quick access\n    this.cachedCities = [];\n    // Dynamic theme properties\n    this.currentTheme = 'day-clear';\n    this.backgroundClass = 'bg-day-clear';\n    this.isDaytime = true;\n    this.currentWeatherType = 'clear';\n    this.destroy$ = new Subject();\n    this.updateTimeBasedTheme();\n  }\n  ngOnInit() {\n    this.setupCitySearch();\n    this.loadCachedCities();\n    this.updateTimeBasedTheme();\n    // Update theme every minute\n    setInterval(() => {\n      this.updateTimeBasedTheme();\n    }, 60000);\n    // Subscribe to service observables\n    this.weatherService.offlineMode$.pipe(takeUntil(this.destroy$)).subscribe(offline => this.offlineMode$.next(offline));\n    this.weatherService.loading$.pipe(takeUntil(this.destroy$)).subscribe(loading => this.loading$.next(loading));\n    this.cityService.searchResults$.pipe(takeUntil(this.destroy$)).subscribe(cities => {\n      this.citySuggestions = cities;\n      this.showSuggestions = cities.length > 0;\n    });\n    this.cityService.loading$.pipe(takeUntil(this.destroy$)).subscribe(loading => this.cityLoading$.next(loading));\n    this.cityService.error$.pipe(takeUntil(this.destroy$)).subscribe(error => this.cityError = error);\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n  setupCitySearch() {\n    this.cityService.createDebouncedSearch(this.searchInput$).pipe(takeUntil(this.destroy$)).subscribe();\n  }\n  onSearchInputChange() {\n    this.searchInput$.next(this.searchCity);\n  }\n  onInputFocus() {\n    if (this.citySuggestions.length > 0) {\n      this.showSuggestions = true;\n    }\n  }\n  onInputBlur() {\n    // Delay hiding to allow for clicks on suggestions\n    setTimeout(() => {\n      this.showSuggestions = false;\n    }, 200);\n  }\n  onKeyDown(event) {\n    if (!this.showSuggestions) return;\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        this.selectedCityIndex = Math.min(this.selectedCityIndex + 1, this.citySuggestions.length - 1);\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        this.selectedCityIndex = Math.max(this.selectedCityIndex - 1, -1);\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (this.selectedCityIndex >= 0) {\n          this.selectCity(this.citySuggestions[this.selectedCityIndex]);\n        } else {\n          this.searchWeather();\n        }\n        break;\n      case 'Escape':\n        this.showSuggestions = false;\n        this.selectedCityIndex = -1;\n        break;\n    }\n  }\n  selectCity(city) {\n    this.searchCity = city.name;\n    this.currentCity = city.name;\n    this.showSuggestions = false;\n    this.selectedCityIndex = -1;\n    this.searchWeather();\n  }\n  searchWeather() {\n    if (!this.searchCity.trim()) return;\n    this.error = null;\n    this.currentCity = this.searchCity;\n    this.addToCachedCities(this.searchCity);\n    if (this.offlineMode$.value) {\n      this.getOfflineWeather();\n    } else {\n      this.getOnlineWeather();\n    }\n  }\n  updateTimeBasedTheme() {\n    const now = new Date();\n    const hours = now.getHours();\n    // Determine if it's daytime (6 AM to 6 PM)\n    this.isDaytime = hours >= 6 && hours < 18;\n    // Update theme based on weather and time\n    this.updateTheme();\n  }\n  updateTheme() {\n    if (this.forecasts.length > 0) {\n      const currentWeather = this.forecasts[0];\n      this.currentWeatherType = this.getWeatherType(currentWeather.description);\n    } else {\n      this.currentWeatherType = 'clear';\n    }\n    const timePrefix = this.isDaytime ? 'day' : 'night';\n    this.currentTheme = `${timePrefix}-${this.currentWeatherType}`;\n    this.backgroundClass = `bg-${this.currentTheme}`;\n  }\n  getWeatherType(description) {\n    const desc = description.toLowerCase();\n    if (desc.includes('rain') || desc.includes('drizzle')) return 'rain';\n    if (desc.includes('storm') || desc.includes('thunder')) return 'storm';\n    if (desc.includes('snow') || desc.includes('blizzard')) return 'snow';\n    if (desc.includes('dust') || desc.includes('sand')) return 'dust';\n    if (desc.includes('fog') || desc.includes('mist') || desc.includes('haze')) return 'fog';\n    if (desc.includes('cloud')) return 'cloudy';\n    if (desc.includes('wind')) return 'windy';\n    return 'clear';\n  }\n  getThemeColors() {\n    const themes = {\n      'day-clear': {\n        primary: '#FFD700',\n        secondary: '#87CEEB',\n        accent: '#FFA500'\n      },\n      'night-clear': {\n        primary: '#4A90E2',\n        secondary: '#2C3E50',\n        accent: '#F39C12'\n      },\n      'day-rain': {\n        primary: '#6C7B7F',\n        secondary: '#34495E',\n        accent: '#3498DB'\n      },\n      'night-rain': {\n        primary: '#2C3E50',\n        secondary: '#34495E',\n        accent: '#3498DB'\n      },\n      'day-storm': {\n        primary: '#4A4A4A',\n        secondary: '#2C2C2C',\n        accent: '#9B59B6'\n      },\n      'night-storm': {\n        primary: '#1A1A1A',\n        secondary: '#000000',\n        accent: '#8E44AD'\n      },\n      'day-snow': {\n        primary: '#E8F4FD',\n        secondary: '#BDC3C7',\n        accent: '#3498DB'\n      },\n      'night-snow': {\n        primary: '#34495E',\n        secondary: '#2C3E50',\n        accent: '#85C1E9'\n      },\n      'day-dust': {\n        primary: '#D4AF37',\n        secondary: '#CD853F',\n        accent: '#DEB887'\n      },\n      'night-dust': {\n        primary: '#8B4513',\n        secondary: '#A0522D',\n        accent: '#F4A460'\n      },\n      'day-fog': {\n        primary: '#D3D3D3',\n        secondary: '#A9A9A9',\n        accent: '#708090'\n      },\n      'night-fog': {\n        primary: '#696969',\n        secondary: '#2F4F4F',\n        accent: '#778899'\n      },\n      'day-cloudy': {\n        primary: '#87CEEB',\n        secondary: '#B0C4DE',\n        accent: '#4682B4'\n      },\n      'night-cloudy': {\n        primary: '#2F4F4F',\n        secondary: '#36454F',\n        accent: '#5F9EA0'\n      },\n      'day-windy': {\n        primary: '#87CEEB',\n        secondary: '#B0E0E6',\n        accent: '#00CED1'\n      },\n      'night-windy': {\n        primary: '#2F4F4F',\n        secondary: '#36454F',\n        accent: '#4682B4'\n      }\n    };\n    return themes[this.currentTheme] || themes['day-clear'];\n  }\n  getOnlineWeather() {\n    this.weatherService.getWeatherForecast(this.searchCity, false).subscribe({\n      next: response => {\n        this.lastSearchResponse = {\n          city: response.city,\n          forecasts: response.forecasts,\n          offline_mode: response.offline_mode,\n          from_cache: response.from_cache,\n          timestamp: response.timestamp,\n          total_days: response.total_days || 3\n        };\n        this.forecasts = response.forecasts;\n        this.error = null;\n        // Update theme based on new weather data\n        this.updateTheme();\n      },\n      error: err => {\n        this.error = err.message || 'Failed to fetch weather data';\n        this.forecasts = [];\n      }\n    });\n  }\n  getOfflineWeather() {\n    this.weatherService.getOfflineWeatherData(this.searchCity).subscribe({\n      next: response => {\n        this.forecasts = response.forecasts || [];\n        this.lastSearchResponse = {\n          city: this.searchCity,\n          forecasts: response.forecasts || [],\n          offline_mode: true,\n          from_cache: true,\n          timestamp: new Date().toISOString(),\n          total_days: 3\n        };\n        this.error = null;\n        // Update theme based on new weather data\n        this.updateTheme();\n      },\n      error: err => {\n        this.error = err.message || 'No cached data available';\n        this.forecasts = [];\n      }\n    });\n  }\n  toggleOfflineMode() {\n    const newMode = !this.offlineMode$.value;\n    this.offlineMode$.next(newMode);\n    this.weatherService.setOfflineMode(newMode);\n  }\n  loadCachedCities() {\n    const cached = localStorage.getItem('cachedCities');\n    if (cached) {\n      this.cachedCities = JSON.parse(cached);\n    }\n  }\n  addToCachedCities(city) {\n    if (!this.cachedCities.includes(city)) {\n      this.cachedCities.unshift(city);\n      this.cachedCities = this.cachedCities.slice(0, 5); // Keep only 5\n      localStorage.setItem('cachedCities', JSON.stringify(this.cachedCities));\n    }\n  }\n  getWeatherIcon(description) {\n    const desc = description.toLowerCase();\n    if (desc.includes('clear')) return '☀️';\n    if (desc.includes('cloud')) return '☁️';\n    if (desc.includes('rain')) return '🌧️';\n    if (desc.includes('storm')) return '⛈️';\n    if (desc.includes('snow')) return '❄️';\n    if (desc.includes('mist') || desc.includes('fog')) return '🌫️';\n    if (desc.includes('wind')) return '💨';\n    return '🌤️';\n  }\n  getAlertClass(fromCache) {\n    return fromCache ? 'alert-warning' : 'alert-success';\n  }\n};\nAppComponent = __decorate([Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})], AppComponent);\nexport { AppComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}