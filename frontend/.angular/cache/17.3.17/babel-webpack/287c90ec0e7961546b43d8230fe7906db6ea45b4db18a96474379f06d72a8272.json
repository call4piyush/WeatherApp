{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { BehaviorSubject, of, throwError } from 'rxjs';\nimport { debounceTime, distinctUntilChanged, switchMap, catchError, map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let CityService = /*#__PURE__*/(() => {\n  class CityService {\n    constructor(http) {\n      this.http = http;\n      this.API_URL = `${environment.apiUrl}/cities`;\n      this.CACHE_KEY = 'weather-app-city-cache';\n      this.CACHE_DURATION = 60 * 60 * 1000; // 1 hour in milliseconds\n      this.searchResultsSubject = new BehaviorSubject([]);\n      this.loadingSubject = new BehaviorSubject(false);\n      this.errorSubject = new BehaviorSubject(null);\n      this.searchResults$ = this.searchResultsSubject.asObservable();\n      this.loading$ = this.loadingSubject.asObservable();\n      this.error$ = this.errorSubject.asObservable();\n      this.loadPopularCities();\n    }\n    /**\n     * Search cities with debounced input\n     */\n    searchCities(query) {\n      this.loadingSubject.next(true);\n      this.errorSubject.next(null);\n      if (!query || query.trim().length < 2) {\n        return this.getPopularCities().pipe(tap(cities => {\n          this.searchResultsSubject.next(cities);\n          this.loadingSubject.next(false);\n        }), catchError(error => this.handleError(error)));\n      }\n      const params = new HttpParams().set('q', query.trim());\n      return this.http.get(`${this.API_URL}/search`, {\n        params\n      }).pipe(map(response => {\n        this.cacheSearchResult(query, response);\n        return response.cities;\n      }), tap(cities => {\n        this.searchResultsSubject.next(cities);\n        this.loadingSubject.next(false);\n      }), catchError(error => {\n        this.loadingSubject.next(false);\n        // Try to get cached results on error\n        const cached = this.getCachedSearchResult(query);\n        if (cached && cached.length > 0) {\n          this.searchResultsSubject.next(cached);\n          this.errorSubject.next('Using cached results - search service temporarily unavailable');\n          return of(cached);\n        }\n        return this.handleError(error);\n      }));\n    }\n    /**\n     * Create debounced search observable\n     */\n    createDebouncedSearch(searchInput$) {\n      return searchInput$.pipe(debounceTime(300), distinctUntilChanged(), switchMap(query => this.searchCities(query)));\n    }\n    /**\n     * Get popular cities\n     */\n    getPopularCities() {\n      const cached = this.getCachedPopularCities();\n      if (cached && cached.length > 0) {\n        return of(cached);\n      }\n      return this.http.get(`${this.API_URL}/popular`).pipe(map(response => {\n        this.cachePopularCities(response.cities);\n        return response.cities;\n      }), catchError(error => {\n        console.warn('Failed to fetch popular cities:', error);\n        return of(this.getFallbackCities());\n      }));\n    }\n    /**\n     * Load initial popular cities\n     */\n    loadPopularCities() {\n      this.getPopularCities().subscribe(cities => this.searchResultsSubject.next(cities), error => {\n        console.error('Failed to load popular cities:', error);\n        this.searchResultsSubject.next(this.getFallbackCities());\n      });\n    }\n    /**\n     * Cache search result\n     */\n    cacheSearchResult(query, response) {\n      try {\n        const cache = this.getCache();\n        cache.searches = cache.searches || {};\n        cache.searches[query.toLowerCase()] = {\n          cities: response.cities,\n          timestamp: Date.now(),\n          type: response.type\n        };\n        localStorage.setItem(this.CACHE_KEY, JSON.stringify(cache));\n      } catch (error) {\n        console.warn('Failed to cache search result:', error);\n      }\n    }\n    /**\n     * Get cached search result\n     */\n    getCachedSearchResult(query) {\n      try {\n        const cache = this.getCache();\n        const result = cache.searches?.[query.toLowerCase()];\n        if (result && Date.now() - result.timestamp < this.CACHE_DURATION) {\n          return result.cities;\n        }\n      } catch (error) {\n        console.warn('Failed to get cached search result:', error);\n      }\n      return null;\n    }\n    /**\n     * Cache popular cities\n     */\n    cachePopularCities(cities) {\n      try {\n        const cache = this.getCache();\n        cache.popularCities = {\n          cities,\n          timestamp: Date.now()\n        };\n        localStorage.setItem(this.CACHE_KEY, JSON.stringify(cache));\n      } catch (error) {\n        console.warn('Failed to cache popular cities:', error);\n      }\n    }\n    /**\n     * Get cached popular cities\n     */\n    getCachedPopularCities() {\n      try {\n        const cache = this.getCache();\n        const popular = cache.popularCities;\n        if (popular && Date.now() - popular.timestamp < this.CACHE_DURATION) {\n          return popular.cities;\n        }\n      } catch (error) {\n        console.warn('Failed to get cached popular cities:', error);\n      }\n      return null;\n    }\n    /**\n     * Get cache object\n     */\n    getCache() {\n      try {\n        const cached = localStorage.getItem(this.CACHE_KEY);\n        return cached ? JSON.parse(cached) : {};\n      } catch (error) {\n        return {};\n      }\n    }\n    /**\n     * Fallback cities when all else fails\n     */\n    getFallbackCities() {\n      return [{\n        name: 'London',\n        country: 'United Kingdom',\n        country_code: 'GB',\n        state: 'England',\n        latitude: 51.5074,\n        longitude: -0.1278,\n        display_name: 'London, England, United Kingdom'\n      }, {\n        name: 'New York',\n        country: 'United States',\n        country_code: 'US',\n        state: 'New York',\n        latitude: 40.7128,\n        longitude: -74.0060,\n        display_name: 'New York, New York, United States'\n      }, {\n        name: 'Tokyo',\n        country: 'Japan',\n        country_code: 'JP',\n        state: 'Tokyo',\n        latitude: 35.6762,\n        longitude: 139.6503,\n        display_name: 'Tokyo, Tokyo, Japan'\n      }, {\n        name: 'Paris',\n        country: 'France',\n        country_code: 'FR',\n        state: 'Île-de-France',\n        latitude: 48.8566,\n        longitude: 2.3522,\n        display_name: 'Paris, Île-de-France, France'\n      }, {\n        name: 'Berlin',\n        country: 'Germany',\n        country_code: 'DE',\n        state: 'Berlin',\n        latitude: 52.5200,\n        longitude: 13.4050,\n        display_name: 'Berlin, Berlin, Germany'\n      }];\n    }\n    /**\n     * Handle HTTP errors\n     */\n    handleError(error) {\n      let errorMessage = 'An error occurred while searching cities';\n      if (error.error instanceof ErrorEvent) {\n        // Client-side error\n        errorMessage = `Network error: ${error.error.message}`;\n      } else {\n        // Server-side error\n        const serverError = error.error;\n        if (serverError && serverError.message) {\n          errorMessage = serverError.message;\n        } else {\n          errorMessage = `Server error: ${error.status} ${error.statusText}`;\n        }\n      }\n      this.errorSubject.next(errorMessage);\n      this.searchResultsSubject.next(this.getFallbackCities());\n      console.error('City search error:', error);\n      return throwError(() => new Error(errorMessage));\n    }\n    /**\n     * Clear cache\n     */\n    clearCache() {\n      try {\n        localStorage.removeItem(this.CACHE_KEY);\n      } catch (error) {\n        console.warn('Failed to clear city cache:', error);\n      }\n    }\n    /**\n     * Check service health\n     */\n    checkHealth() {\n      return this.http.get(`${this.API_URL}/health`);\n    }\n    static {\n      this.ɵfac = function CityService_Factory(t) {\n        return new (t || CityService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: CityService,\n        factory: CityService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return CityService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}