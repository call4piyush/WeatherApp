{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { BehaviorSubject, throwError, of } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let WeatherService = /*#__PURE__*/(() => {\n  class WeatherService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = 'http://localhost:8080/api/v1/weather';\n      this.storageKey = 'weather_cache';\n      this.offlineModeSubject = new BehaviorSubject(false);\n      this.offlineMode$ = this.offlineModeSubject.asObservable();\n      this.loadingSubject = new BehaviorSubject(false);\n      this.loading$ = this.loadingSubject.asObservable();\n      // Check if we're offline\n      this.checkOnlineStatus();\n      // Listen for online/offline events\n      window.addEventListener('online', () => this.setOfflineMode(false));\n      window.addEventListener('offline', () => this.setOfflineMode(true));\n    }\n    checkOnlineStatus() {\n      this.setOfflineMode(!navigator.onLine);\n    }\n    setOfflineMode(isOffline) {\n      this.offlineModeSubject.next(isOffline);\n    }\n    getWeatherForecast(city, forceOffline = false) {\n      this.loadingSubject.next(true);\n      const isOffline = this.offlineModeSubject.value || forceOffline;\n      if (isOffline) {\n        return this.getOfflineWeatherData(city);\n      }\n      const params = new HttpParams().set('city', city).set('offline', 'false');\n      return this.http.get(`${this.baseUrl}/forecast`, {\n        params\n      }).pipe(tap(response => {\n        // Cache the response for offline use\n        this.cacheWeatherData(city, response);\n        this.loadingSubject.next(false);\n      }), catchError(error => {\n        this.loadingSubject.next(false);\n        // If API fails, try to get cached data\n        if (error.status === 0 || error.status >= 500) {\n          const cachedData = this.getCachedWeatherData(city);\n          if (cachedData) {\n            return of(cachedData);\n          }\n        }\n        return this.handleError(error);\n      }));\n    }\n    getOfflineWeatherData(city) {\n      this.loadingSubject.next(true);\n      // First try to get from local cache\n      const cachedData = this.getCachedWeatherData(city);\n      if (cachedData) {\n        this.loadingSubject.next(false);\n        return of(cachedData);\n      }\n      // If no cache, try to get from backend's offline endpoint\n      return this.http.get(`${this.baseUrl}/offline/${city}`).pipe(tap(response => {\n        this.cacheWeatherData(city, response);\n        this.loadingSubject.next(false);\n      }), catchError(error => {\n        this.loadingSubject.next(false);\n        return this.handleError(error);\n      }));\n    }\n    cacheWeatherData(city, data) {\n      try {\n        const cache = this.getAllCachedData();\n        cache[city.toLowerCase()] = {\n          data,\n          timestamp: Date.now()\n        };\n        localStorage.setItem(this.storageKey, JSON.stringify(cache));\n      } catch (error) {\n        console.warn('Failed to cache weather data:', error);\n      }\n    }\n    getCachedWeatherData(city) {\n      try {\n        const cache = this.getAllCachedData();\n        const cityData = cache[city.toLowerCase()];\n        if (cityData && this.isCacheValid(cityData.timestamp)) {\n          // Mark as offline mode in the cached data\n          return {\n            ...cityData.data,\n            offline_mode: true\n          };\n        }\n      } catch (error) {\n        console.warn('Failed to get cached weather data:', error);\n      }\n      return null;\n    }\n    getAllCachedData() {\n      try {\n        const cached = localStorage.getItem(this.storageKey);\n        return cached ? JSON.parse(cached) : {};\n      } catch {\n        return {};\n      }\n    }\n    isCacheValid(timestamp) {\n      const cacheExpiryTime = 30 * 60 * 1000; // 30 minutes\n      return Date.now() - timestamp < cacheExpiryTime;\n    }\n    clearCache() {\n      localStorage.removeItem(this.storageKey);\n    }\n    getCachedCities() {\n      try {\n        const cache = this.getAllCachedData();\n        return Object.keys(cache).map(city => city.charAt(0).toUpperCase() + city.slice(1));\n      } catch {\n        return [];\n      }\n    }\n    handleError(error) {\n      let errorMessage = 'An unexpected error occurred';\n      if (error.error instanceof ErrorEvent) {\n        // Client-side error\n        errorMessage = `Error: ${error.error.message}`;\n      } else {\n        // Server-side error\n        if (error.error && error.error.message) {\n          errorMessage = error.error.message;\n        } else {\n          switch (error.status) {\n            case 0:\n              errorMessage = 'Unable to connect to server. Please check your internet connection.';\n              break;\n            case 404:\n              errorMessage = 'Weather data not found for this city.';\n              break;\n            case 500:\n              errorMessage = 'Server error. Please try again later.';\n              break;\n            default:\n              errorMessage = `Error: ${error.status} - ${error.message}`;\n          }\n        }\n      }\n      console.error('Weather Service Error:', error);\n      return throwError(() => new Error(errorMessage));\n    }\n    static {\n      this.ɵfac = function WeatherService_Factory(t) {\n        return new (t || WeatherService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WeatherService,\n        factory: WeatherService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WeatherService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}